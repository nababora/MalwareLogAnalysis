import os
import re
import time
from multiprocessing import Process, Queue, Lock
from sqlalchemy import Column, ForeignKey, Integer, String, create_engine
from sqlalchemy.orm import relationship, sessionmaker
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()


class Malware(Base):
    __tablename__ = 'malware'
    id = Column(Integer, primary_key=True)
    name = Column(String, nullable=False)

    branches = relationship('Branch', backref='malware')

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return "<Malware(id=%s, name='%s')>" % (self.id, self.name)


class Branch(Base):
    __tablename__ = 'branch'
    id = Column(Integer, primary_key=True)
    order = Column(Integer, nullable=False)

    src_addr = Column(Integer, nullable=False)
    dst_addr = Column(Integer, nullable=False)

    dll = Column(String)
    symbol = Column(String)

    malware_id = Column(Integer, ForeignKey('malware.id'), nullable=False)

    def __init__(self, mal, order, src_addr, dst_addr, dll, symbol):
        self.malware_id = mal
        self.order = order

        self.src_addr = src_addr
        self.dst_addr = dst_addr

        self.dll = dll
        self.symbol = symbol

    def __repr__(self):
        return "<Branch(id=%s, mal_id=%s, src=%s, dst=%s, dll=%s, name=%s)>" \
            % (self.id, self.malware_id, self.src_addr, self.dst_addr, self.dll, self.symbol)


def init_db(db_url='sqlite:///data/malware.db'):
    engine = create_engine(db_url)
    Base.metadata.create_all(engine)


def log_writer(proc_cnt=10,
               log_dir='logs',
               db_url='sqlite:///data/malware.db',
               is_log=False):
    def writer(proc_id, lock, queue, output):
        engine = create_engine(db_url)

        Session = sessionmaker()
        Session.configure(bind=engine)

        sess = Session()

        while True:
            log = queue.get()
            if log is None:
                lock.acquire()
                sess.commit()
                lock.release()

                output.put(proc_id)
                break

            if is_log:
                print('proc %d : log %s' % (proc_id, log))

            with open(os.path.join(log_dir, log)) as f:
                name = f.readline()
                name = re.findall(r'\[(.*)\]', name)[0]

                mal = Malware(name)
                sess.add(mal)

                lock.acquire()
                sess.commit()
                lock.release()

                i = 0
                for branch in f.readlines():
                    i += 1

                    if branch.startswith('++'):
                        sess.add(ind)
                    else:
                        tmp = branch[1:-1].split(',')
                        if len(tmp) == 4:
                            src, dst, dll, sym = tmp
                        elif len(tmp) == 3:
                            src, dst, dll = tmp
                            sym = ''

                        src = int(src, 16)
                        dst = int(dst, 16)

                        ind = Branch(mal.id, i, src, dst, dll, sym)

                        sess.add(ind)

    lock = Lock()
    queue = Queue()
    output = Queue()

    for i in range(proc_cnt):
        proc = Process(target=writer, args=(i, lock, queue, output))
        proc.daemon = True
        proc.start()

    for log in os.listdir(log_dir):
        queue.put(log)

    for i in range(proc_cnt):
        queue.put(None)

    end = 0
    target_sum = sum(range(proc_cnt))

    while end != target_sum:
        end += output.get()
